<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Single Perceptron Training Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .node {
            transition: all 0.3s ease-in-out;
        }
        .input-node { fill: #60a5fa; } /* blue-400 */
        .output-node { fill: #f87171; } /* red-400 */
        .bias-node { fill: #a78bfa; } /* violet-400 */
        
        .node-text {
            font-size: 14px;
            font-weight: bold;
            fill: #ffffff;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
        }
        .value-text {
            font-size: 12px;
            font-family: monospace;
            fill: #1f2937; /* gray-800 */
        }
        .weight-text {
            font-size: 10px;
            font-family: monospace;
            fill: #4b5563; /* gray-600 */
        }

        .line {
            stroke: #9ca3af; /* gray-400 */
            stroke-width: 1.5;
            transition: all 0.3s ease-in-out;
        }

        /* Highlighting classes */
        .node-highlight {
            stroke: #2563eb; /* blue-600 */
            stroke-width: 4;
        }
        .line-highlight {
            stroke: #db2777; /* pink-600 */
            stroke-width: 4;
        }
        .output-highlight {
            stroke: #16a34a; /* green-600 */
            stroke-width: 4;
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .highlight-op { color: #ef4444; } /* red-500 */
        .highlight-res { color: #22c55e; } /* green-500 */
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center min-h-screen p-4">

    <div class="w-full max-w-6xl bg-white rounded-xl shadow-lg p-6">
        <h1 class="text-3xl font-bold text-center text-gray-900 mb-2">Single Perceptron Training</h1>
        <p class="text-center text-gray-500 mb-6">Visualizing the step-by-step weight adjustment process.</p>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
            <!-- SVG Network Diagram -->
            <div id="network-container" class="w-full">
                <svg id="network-svg" viewBox="0 0 400 300"></svg>
            </div>
            
            <!-- Step-by-step Explanation -->
            <div id="explanation-container" class="bg-gray-50 p-6 rounded-lg h-full min-h-[300px]">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div class="mt-8 flex justify-center gap-4">
            <button id="prev-btn" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600 transition-colors shadow-md focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-50">
                Previous
            </button>
            <button id="next-btn" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 transition-colors shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                Start
            </button>
        </div>
    </div>

<script>
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.getElementById('network-svg');
    const explanationContainer = document.getElementById('explanation-container');
    const nextButton = document.getElementById('next-btn');
    const prevButton = document.getElementById('prev-btn');

    // --- Network Structure ---
    const inputs = [
        { id: 'x1', cx: 50, cy: 80, class: 'input-node', label: 'x1' },
        { id: 'x2', cx: 50, cy: 150, class: 'input-node', label: 'x2' },
        { id: 'b', cx: 50, cy: 220, class: 'bias-node', label: 'bias (x0)' }
    ];
    const outputs = [
        { id: 'y', cx: 300, cy: 150, class: 'output-node', label: 'y' }
    ];

    let elements = {};

    function createText(x, y, content, className, id) {
        const text = document.createElementNS(svgNS, 'text');
        text.setAttribute('x', x);
        text.setAttribute('y', y);
        text.setAttribute('class', className);
        if(id) text.id = id;
        text.textContent = content;
        return text;
    }
    
    // Draw lines (weights)
    inputs.forEach(input => {
        outputs.forEach(output => {
            const line = document.createElementNS(svgNS, 'line');
            const lineId = `w-${input.id}-${output.id}`;
            line.id = lineId;
            line.setAttribute('x1', input.cx + 20);
            line.setAttribute('y1', input.cy);
            line.setAttribute('x2', output.cx - 20);
            line.setAttribute('y2', output.cy);
            line.setAttribute('class', 'line');
            svg.appendChild(line);
            elements[lineId] = line;

            // Weight text
            const wx = (input.cx + output.cx) / 2 - (input.id === 'x2' ? 40 : 20);
            const wy = (input.cy + output.cy) / 2 + (input.id === 'x2' ? -15 : 0);
            const weightTextId = `wt-${input.id}-${output.id}`;
            const weightText = createText(wx, wy, '', 'weight-text', weightTextId);
            svg.appendChild(weightText);
            elements[weightTextId] = weightText;
        });
    });

    // Draw nodes
    [...inputs, ...outputs].forEach(nodeInfo => {
        const group = document.createElementNS(svgNS, 'g');
        
        const circle = document.createElementNS(svgNS, 'circle');
        circle.id = nodeInfo.id;
        circle.setAttribute('cx', nodeInfo.cx);
        circle.setAttribute('cy', nodeInfo.cy);
        circle.setAttribute('r', 20);
        circle.setAttribute('class', `node ${nodeInfo.class}`);
        group.appendChild(circle);
        elements[nodeInfo.id] = circle;

        const label = createText(nodeInfo.cx, nodeInfo.cy, nodeInfo.label, 'node-text');
        group.appendChild(label);
        
        const valueId = `val-${nodeInfo.id}`;
        const valueText = createText(nodeInfo.cx, nodeInfo.cy + 30, '', 'value-text', valueId);
        group.appendChild(valueText);
        elements[valueId] = valueText;
        
        svg.appendChild(group);
    });
    
    // --- State and Steps ---
    let currentStep = -1;
    const initialData = {
        w: [2, -1, 1], // Corresponds to [w0 (bias), w1, w2]
        eta: 0.1,
        trainingData: [
            { input: [1, 1, 1], desired: 1 },    // Instance 1
            { input: [1, 2, 0.4], desired: 0 },  // Instance 2
            { input: [1, -2, 0], desired: 1 }    // Instance 3
        ]
    };

    let data = {};

    function resetData() {
        data = JSON.parse(JSON.stringify(initialData));
    }

    function clearHighlights() {
        Object.values(elements).forEach(el => {
            el.classList.remove('node-highlight', 'line-highlight', 'output-highlight');
        });
    }
    
    function updateWeightText(weights) {
        elements['wt-b-y'].textContent = `w0=${weights[0].toFixed(2)}`;
        elements['wt-x1-y'].textContent = `w1=${weights[1].toFixed(2)}`;
        elements['wt-x2-y'].textContent = `w2=${weights[2].toFixed(2)}`;
    }
    
    function setInputValues(inputVector) {
        elements['val-b'].textContent = `in: ${inputVector[0]}`;
        elements['val-x1'].textContent = `in: ${inputVector[1]}`;
        elements['val-x2'].textContent = `in: ${inputVector[2]}`;
    }

    const steps = [
        // --- INSTANCE 1 ---
        {
            title: "Instance 1: Start",
            explanation: `
                <p>We begin with the first training data point. The network has its initial weights.</p>
                <p class="mt-4"><strong>Input x:</strong> [x0=1, x1=1, x2=1]</p>
                <p><strong>Desired Output d:</strong> 1</p>`,
            action: () => {
                clearHighlights();
                updateWeightText(data.w);
                setInputValues(data.trainingData[0].input);
                ['b', 'x1', 'x2'].forEach(id => elements[id].classList.add('node-highlight'));
                elements['val-y'].textContent = '';
            }
        },
        {
            title: "Instance 1: Calculate Net Input",
            explanation: `
                <p>The net input is the weighted sum of the inputs: <br><strong>net = w0*x0 + w1*x1 + w2*x2</strong></p>
                <p class="mt-2 text-sm bg-gray-200 p-2 rounded font-mono">
                    (2 * 1) + (-1 * 1) + (1 * 1) = <strong class="highlight-res">2</strong>
                </p>`,
            action: () => {
                clearHighlights();
                ['b', 'x1', 'x2'].forEach(id => {
                    elements[id].classList.add('node-highlight');
                    elements[`w-${id}-y`].classList.add('line-highlight');
                });
                elements['y'].classList.add('output-highlight');
                elements['val-y'].textContent = 'net: 2';
            }
        },
        {
            title: "Instance 1: Apply Activation",
            explanation: `
                <p>The activation function is a simple threshold: if net > 0, output is 1, else 0.</p>
                <p class="mt-2"><strong>net = 2</strong>, which is > 0, so... </p>
                <p><strong>Actual Output y:</strong> <strong class="highlight-res">1</strong></p>`,
            action: () => {
                 elements['val-y'].textContent = 'y: 1';
            }
        },
        {
            title: "Instance 1: Calculate Error",
            explanation: `
                <p>Error is the difference between the desired and actual output: <strong>e = d - y</strong></p>
                <p class="mt-2 text-sm bg-gray-200 p-2 rounded font-mono">
                    e = 1 - 1 = <strong class="highlight-res">0</strong>
                </p>
                <p class="mt-2">The error is 0, so the prediction was correct. <strong>No weight update is needed.</strong></p>`,
            action: () => {
                elements['val-y'].textContent = 'e: 0';
            }
        },
        // --- INSTANCE 2 ---
        {
            title: "Instance 2: Start",
            explanation: `
                <p>Now we process the second training data point with the current weights.</p>
                <p class="mt-4"><strong>Input x:</strong> [x0=1, x1=2, x2=0.4]</p>
                <p><strong>Desired Output d:</strong> 0</p>`,
            action: () => {
                clearHighlights();
                updateWeightText(data.w);
                setInputValues(data.trainingData[1].input);
                ['b', 'x1', 'x2'].forEach(id => elements[id].classList.add('node-highlight'));
                elements['val-y'].textContent = '';
            }
        },
         {
            title: "Instance 2: Calculate Net Input",
            explanation: `
                <p>We calculate the net input again with the new data.</p>
                <p class="mt-2 text-sm bg-gray-200 p-2 rounded font-mono">
                    (2 * 1) + (-1 * 2) + (1 * 0.4) = <strong class="highlight-res">0.4</strong>
                </p>`,
            action: () => {
                clearHighlights();
                ['b', 'x1', 'x2'].forEach(id => {
                    elements[id].classList.add('node-highlight');
                    elements[`w-${id}-y`].classList.add('line-highlight');
                });
                elements['y'].classList.add('output-highlight');
                elements['val-y'].textContent = 'net: 0.4';
            }
        },
        {
            title: "Instance 2: Apply Activation",
            explanation: `
                <p>The activation function is a simple threshold: if net > 0, output is 1, else 0.</p>
                <p class="mt-2"><strong>net = 0.4</strong>, which is > 0, so... </p>
                <p><strong>Actual Output y:</strong> <strong class="highlight-res">1</strong></p>`,
            action: () => {
                 elements['val-y'].textContent = 'y: 1';
            }
        },
        {
            title: "Instance 2: Calculate Error",
            explanation: `
                <p>Calculate the error: <strong>e = d - y</strong></p>
                <p class="mt-2 text-sm bg-gray-200 p-2 rounded font-mono">
                    e = 0 - 1 = <strong class="highlight-op">-1</strong>
                </p>
                <p class="mt-2">The error is not 0. <strong>A weight update is required.</strong></p>`,
            action: () => {
                elements['val-y'].textContent = 'e: -1';
            }
        },
        {
            title: "Instance 2: Update Weights",
            explanation: `
                <p>We update weights using the formula: <br><strong>W_new = W_old + η * e * x</strong></p>
                <p class="mt-2 text-sm bg-gray-200 p-2 rounded font-mono">
                   Δw = 0.1 * -1 * [1, 2, 0.4] <br>
                   Δw = [-0.1, -0.2, -0.04]<br><br>
                   W_new = [2, -1, 1] + [-0.1, -0.2, -0.04] <br>
                   W_new = <strong class="highlight-res">[1.9, -1.2, 0.96]</strong>
                </p>`,
            action: () => {
                const { input } = data.trainingData[1];
                const net = data.w[0]*input[0] + data.w[1]*input[1] + data.w[2]*input[2];
                const actual = net > 0 ? 1 : 0;
                const error = data.trainingData[1].desired - actual;

                if (error !== 0) {
                    for(let i=0; i < data.w.length; i++) {
                        const delta_w = data.eta * error * input[i];
                        data.w[i] += delta_w;
                    }
                }
                updateWeightText(data.w);
                ['b', 'x1', 'x2'].forEach(id => {
                    elements[`w-${id}-y`].classList.add('line-highlight');
                });
            }
        },
        // --- INSTANCE 3 ---
         {
            title: "Instance 3: Start",
            explanation: `
                <p>Finally, we process the third data point with the newly updated weights.</p>
                <p class="mt-4"><strong>Input x:</strong> [x0=1, x1=-2, x2=0]</p>
                <p><strong>Desired Output d:</strong> 1</p>`,
            action: () => {
                clearHighlights();
                updateWeightText(data.w);
                setInputValues(data.trainingData[2].input);
                ['b', 'x1', 'x2'].forEach(id => elements[id].classList.add('node-highlight'));
                elements['val-y'].textContent = '';
            }
        },
        {
            title: "Instance 3: Calculate Net Input",
            explanation: `
                <p>Calculate net input with the updated weights.</p>
                <p class="mt-2 text-sm bg-gray-200 p-2 rounded font-mono">
                    (1.9 * 1) + (-1.2 * -2) + (0.96 * 0) = <strong class="highlight-res">4.3</strong>
                </p>`,
            action: () => {
                clearHighlights();
                ['b', 'x1', 'x2'].forEach(id => {
                    elements[id].classList.add('node-highlight');
                    elements[`w-${id}-y`].classList.add('line-highlight');
                });
                elements['y'].classList.add('output-highlight');
                elements['val-y'].textContent = 'net: 4.3';
            }
        },
        {
            title: "Instance 3: Apply Activation",
            explanation: `
                <p>The activation function is a simple threshold: if net > 0, output is 1, else 0.</p>
                <p class="mt-2"><strong>net = 4.3</strong>, which is > 0, so... </p>
                <p><strong>Actual Output y:</strong> <strong class="highlight-res">1</strong></p>`,
            action: () => {
                 elements['val-y'].textContent = 'y: 1';
            }
        },
         {
            title: "Instance 3: Calculate Error",
            explanation: `
                <p>Calculate the final error: <strong>e = d - y</strong></p>
                <p class="mt-2 text-sm bg-gray-200 p-2 rounded font-mono">
                    e = 1 - 1 = <strong class="highlight-res">0</strong>
                </p>
                <p class="mt-2">The error is 0. The network correctly classified this instance. <strong>No weight update is needed.</strong></p>`,
            action: () => {
                elements['val-y'].textContent = 'e: 0';
            }
        },
        {
            title: "Training Complete",
            explanation: `<p>The perceptron has processed all training instances. The weights have been adjusted based on the errors. You can restart to see the process again.</p>`,
            action: () => {
                clearHighlights();
                setInputValues(['', '', '']);
                elements['val-y'].textContent = '';
            }
        }
    ];

    function updateButtonsState() {
        prevButton.disabled = currentStep <= 0;
        prevButton.classList.toggle('opacity-50', prevButton.disabled);
        prevButton.classList.toggle('cursor-not-allowed', prevButton.disabled);

        if (currentStep >= steps.length - 1) {
            nextButton.innerText = 'Restart';
        } else if (currentStep < 0) {
            nextButton.innerText = 'Start';
        } else {
            nextButton.innerText = 'Next';
        }
    }

    // This function is complex. It re-calculates the state from the beginning
    // when you go backwards to ensure the weights are always correct for the current step.
    function renderStep(stepIndex, isSteppingBack = false) {
        if (stepIndex < 0 || stepIndex >= steps.length) {
            return;
        }

        const stepToRender = steps[stepIndex];
        
        // If we are stepping backwards, we need to reset and recalculate the state
        // up to the point of the step we want to show.
        if (isSteppingBack) {
            resetData(); // Start from initial weights
            // Silently run the 'action' of all steps leading up to the target step
            for (let i = 0; i < stepIndex; i++) {
                const silentStep = steps[i];
                 // We only care about actions that update weights
                if (silentStep.title.includes("Update Weights")) {
                    silentStep.action();
                }
            }
        }
        
        currentStep = stepIndex;
        
        explanationContainer.innerHTML = `
            <div class="fade-in">
                <h2 class="text-xl font-bold text-blue-700 mb-4">${stepToRender.title}</h2>
                <div>${stepToRender.explanation}</div>
            </div>`;

        // Always run the action of the final step to update the UI
        stepToRender.action();

        updateButtonsState();
    }
    
    nextButton.addEventListener('click', () => {
        let nextStepIndex = currentStep + 1;
        if (nextStepIndex >= steps.length) {
            resetData();
            nextStepIndex = 0; // Restart
        }
        renderStep(nextStepIndex, false);
    });

    prevButton.addEventListener('click', () => {
        let prevStepIndex = currentStep - 1;
        if (prevStepIndex >= 0) {
            renderStep(prevStepIndex, true);
        }
    });

    function initialize() {
        currentStep = -1;
        resetData();
        explanationContainer.innerHTML = `
            <h2 class="text-xl font-bold text-blue-700 mb-4">Welcome!</h2>
            <p>This is an interactive visualization of a single Perceptron learning.</p>
            <p class="mt-2">The diagram shows the network structure: two inputs (x1, x2), a bias input (x0), and one output neuron.</p>
            <p class="mt-4">Click the "Start" button to walk through the training process for three data points, step-by-step.</p>
        `;
        updateWeightText(data.w);
        clearHighlights();
        setInputValues(['', '', '']);
        elements['val-y'].textContent = '';
        updateButtonsState();
    }
    
    initialize();

</script>
</body>

</html>
